from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from app.schemas.base import BaseSchema # For id, created_at, updated_at

# --- Base Question Schemas ---
class QuestionBase(BaseModel):
    title: Optional[str] = Field(None, max_length=255)
    content: str
    question_type: Optional[str] = Field(None, description="E.g., MCQ, Short Answer, Essay. Auto-detected or set.")
    subject_id: Optional[int] = None # Will be linked to a Subject schema/model later

    difficulty_level_label: Optional[str] = Field(None, description="E.g., Easy, Medium, Hard")
    difficulty_level_score: Optional[float] = Field(None, ge=0, le=1, description="Numerical difficulty score 0.0-1.0")

    source: Optional[str] = Field(None, max_length=255, description="Origin of the question, e.g., Exam name, Textbook")
    year: Optional[int] = Field(None, description="Year of the source/exam")
    priority_score: Optional[float] = Field(None, description="Calculated importance/frequency score")

    # keywords: Optional[List[str]] = [] # Conceptual: list of keywords
    # tags: Optional[List[str]] = [] # Conceptual: list of tag names

    # Conceptual fields for AI processing results / links
    # vector_id: Optional[str] = Field(None, description="ID linking to the vector in ChromaDB. Not directly user-settable.")
    # raw_ocr_text: Optional[str] = Field(None, description="Raw text from OCR if applicable.")
    # image_url: Optional[str] = Field(None, description="URL of an associated image.")

    class Config:
        from_attributes = True


# --- Schemas for API Operations ---

# Schema for creating a question (input)
class QuestionCreate(QuestionBase):
    # Fields that are typically set by user/admin during creation
    # AI-derived fields (difficulty, type, keywords) might be populated later by a processing pipeline,
    # or provided if known during creation.
    pass

# Schema for updating a question (input)
class QuestionUpdate(QuestionBase):
    # Allow partial updates, so all fields are optional
    title: Optional[str] = Field(None, max_length=255)
    content: Optional[str] = None
    question_type: Optional[str] = None
    subject_id: Optional[int] = None
    difficulty_level_label: Optional[str] = None
    difficulty_level_score: Optional[float] = None
    source: Optional[str] = None
    year: Optional[int] = None
    priority_score: Optional[float] = None
    # keywords: Optional[List[str]] = None
    # tags: Optional[List[str]] = None
    # image_url: Optional[str] = None


# Schema for reading a question (output from API)
class QuestionRead(QuestionBase, BaseSchema): # Includes id, created_at, updated_at from BaseSchema
    # Add any fields here that are generated by the system and should be readable,
    # but are not part of QuestionBase (e.g., if not directly from the model or different formatting).

    # Example: If subject was a relationship, you might have a nested SubjectRead schema here
    # subject: Optional[SubjectRead] = None

    # AI related fields that might be exposed
    # ai_explanation: Optional[str] = None # Placeholder for AI-generated explanation
    is_processed_for_embedding: Optional[bool] = False
    # similar_questions: Optional[List['QuestionReadSimilar']] = [] # For related questions

    class Config:
        from_attributes = True


# Schema for representing a similar question in responses (to avoid circular dependencies with full QuestionRead)
class QuestionReadSimilar(BaseModel):
    id: int
    title: Optional[str]
    content: str # Or a snippet
    similarity_score: Optional[float] = None

    class Config:
        from_attributes = True

# If QuestionRead needs to include similar_questions using QuestionReadSimilar to break circularity
# QuestionRead.model_rebuild() # Pydantic v2
# QuestionReadSimilar.model_rebuild() # Pydantic v2

# --- Schemas for AI interactions / processing results ---

class QuestionProcessRequest(BaseModel):
    """Schema for requesting AI processing for a question."""
    question_id: int
    force_reprocess: bool = False # Whether to reprocess even if already processed

class QuestionProcessResult(BaseModel):
    """Schema for results of AI processing of a question."""
    question_id: int
    status: str # e.g., "processed", "failed", "pending"
    extracted_text: Optional[str] = None # From OCR/PDF
    subject: Optional[str] = None
    topic: Optional[str] = None
    detected_question_type: Optional[str] = None
    difficulty_label: Optional[str] = None
    difficulty_score: Optional[float] = None
    keywords: Optional[List[str]] = None
    embedding_vector_id: Optional[str] = None # ID in vector DB
    error_message: Optional[str] = None


class QuestionSearchQuery(BaseModel):
    query_text: str
    top_k: int = Field(5, ge=1, le=50)
    subject_filter: Optional[str] = None
    difficulty_filter: Optional[str] = None
    # Add other filters as needed

class QuestionSearchResultItem(QuestionRead): # Inherits fields from QuestionRead
    distance: Optional[float] = None # Semantic distance from query
    # Any other search-specific fields


# Placeholder for other related schemas as needed
# class SubjectRead(BaseSchema):
# name: str
# code: Optional[str] = None
# department: Optional[str] = None

# class TagRead(BaseSchema):
# name: str

# class ExplanationRead(BaseSchema):
# content: str
# type: str
# ai_generated: bool
# question_id: int
